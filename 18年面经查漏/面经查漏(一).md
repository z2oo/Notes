### JVM 有哪些分区？
程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。  

栈帧包括局部变量表，操作数栈，方法的返回地址，指向当前方法所属的类的运行时常量池的引用，附加信息。  

1.7 之后，运行时常量池放在堆内存中。  

### MySQL 使用的引擎
1. MyIsam：不支持事务，适用于选择密集型，插入密集型，MySQL 默认的引擎。
2. Innodb：适用于更新密集型，支持事务，自动灾难恢复，行级锁，外键约束。
3. memory：出发点是速度，采用的逻辑存储介质是内存
4. merge：一组MyIsam 表的组合

### Executor 继承关系

```
graph LR
ThreadPoolExecutor-->AbstractExecutorService抽象类
```

```
graph LR
AbstractExecutorService抽象类-->ExecutorService接口
```

```
graph LR
ExecutorService接口-->Executor接口
```

#### 线程池的状态
1. 当线程池创建后，初始为 running 状态。
2. 调用 shutdown 方法后，处于 shutdown 状态，此时不再接受新的任务，等待已有的任务执行完毕。
3. 调用 shutdownnow 方法后，进入 stop 状态，不再接受新的任务，并且会尝试终止正在执行的任务。
4. 当处于 shutdown 或 stop 状态，并且所有工作线程已经销毁，任务缓存队列已经清空，线程池被设为 terminated 状态。  

### GC
对象是否存活：
1. 引用计数法 缺点：很难解决对象之间循环引用的问题 
2. 可达性分析法 基本思想：通过将一些列被称为 GC roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC root 没有任何引用链相连 ，即这个对象不可达，则证明此对象是不可用的。

#### 可作为 GC roots 的对象
- java 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类的静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI 引用的对象  


### 引用
强引用 > 软引用 > 弱引用 > 虚引用  

#### 强引用
只要强引用存在，垃圾回收器永远不会回收掉被引用的对象  

```
Object obj = new Object();
obj.equals(new Object());
```
这样 obj 对象对后面 new Objec()的一个强引用，只有当这个引用被释放之后，对象才会被释放。  

#### 软引用
软引用是用来描述一些还有用但并非必需的对象。  

在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。  

`SoftReference`  

```
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
sf.get();//有时候会返回null
```
这时候 sf 是对 obj 的一个软引用，通过 sf.get() 方法可以去到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回 null  

软引用主要用于实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。  

#### 为什么需要使用软引用
**使用软引用构建敏感数据的缓存**  

首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。   

这时我们通常会有两种程序实现方式:一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;另一种是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。    

很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。

#### 弱引用
弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。  

当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象  
`WeakReference`  

#### 虚引用
最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。  

为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。  
`PhantomReference`

### 垃圾收集算法
- 标记-清除算法
- 复制算法
- 标记整理算法

#### 标记-清除算法
标记-清除算法，最基础的收集算法，分为两个阶段，分别是  
标记 和 清除：   
首先，标记出所有需要回收的对象，在标记完成之后统一回收所有被标记的对象。其中，标记的算法既是可达性分析算法。  

它有两个不足：
- 效率问题，标记和清除两个过程的效率都不高  
- 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。  


#### 复制算法
它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。  

这样使得每次都是对整个半区进行内存回收，内存分配时就不用考虑内存碎片等复杂情况，只要一动堆顶指针，按顺序分配内存即可，实现简单，运行高效。  

不过代价是，将内存缩小为原来的一半。

复制收集算法在对象存活率较高时，就要进行较多的复制操作，效率将会变低。

复制算法在对象存活率较高时，会有缺陷。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。  

##### 为什么对新生代采用复制算法
现在的虚拟机都采用这种手机算法来回收新生代，因为新生代中的对象都是 “朝生夕死”的，所以并不需要按照 1：1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。  

当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。  

HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8：1，只有 10% 的内存会被“浪费”。  

我们没办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。  

###### 何谓分配担保
> 好比我们去银行贷款，如果我们信誉良好，在 98% 的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。  
内存的分配担保也一样，如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。

#### 标记-整理算法
标记过程与 “标记-清除” 算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。  

### 分代收集算法
在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。  

而老年代中因为对象存活率极高、没有额外空间对它进行分配担保，就必须使用 “标记-清理” 或者 “标记-整理” 算法来进行回收。  

### 垃圾收集器
#### Serial 收集器（新生）
单线程收集器，只会使用一个 CPU 或一条收集线程去完成垃圾收集工作；而且，在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束——“Stop The World”。  

“Stop The World”，这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。  

这项垃圾收集工作跟打扫房间差不多。  

简单而高效，对于运行在 Client 模式下的虚拟机来说是一个很好的选择。  

#### ParNew 收集器（新生）
Serial 收集器的多线程版本，是运行在 Server 模式下的虚拟机中首选的新生代收集器，因为除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。  

#### Parallel Scavenge 收集器（新生）
使用复制算法的收集器，优势并行的多线程收集器。  

特点：目标 达到一个可控制的吞吐量；具有自适应调节策略。  
> 吞吐量  
所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即 吞吐量 = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间)。

#### Serial Old 收集器（老年）
Serial Old 是 Serial 收集器的老年版本，同样是一个单线程收集器，使用 “标记-整理” 算法。 

在于给 Client 模式下的虚拟机使用。  

#### Parallel Old 收集器（老年）
Parallel Old 是 Parallel Scavenge 收集器的老年版本，使用 多线程，“标记-整理”算法

#### CMS 收集器（老年）
CMS（Concurrent Mark Sweep）收集器是一种以获取**最短回收停顿时间**为目标的收集器，“标记-清除”算法。  

运行过程分为 4 个步骤：
1. **初始标记** (Stop The World)
2. **并发标记** 
3. **重新标记** (Stop The World)
4. **并发清除**

初始标记 —— (Stop The World)，仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快。  

并发标记 —— 进行 GC Roots Tracing 的过程。  

重新标记 —— (Stop The World)，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，当远比并发标记的时间段。

并发清除 —— 清除工作能与用户线程并发进行。  

**优点**：
- 并发清除
- 低停顿

**缺点：**
- CMS 收集器对 CPU 资源非常敏感，并发设计的程序都对 CPU 资源比较敏感。  
- CMS 收集器无法处理浮动垃圾
- 产生大量碎片

#### G1 收集器
与其他收集器相比，具有如下特点：
- 并行与并发
- 分代收集
- 空间整合：G1运行期间不会产生内存空间碎片
- 可预测停顿

它将整个 Java 堆划分为多个大小相等的独立区域 (Region)，还保留有新生代和老年代的概念，当新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。  

G1运作步骤：
1. **初始标记** (Stop The World)
2. **并发标记**
3. **最终标记** (Stop The World)
4. **筛选回收** (Stop The World)

初始标记 —— 仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS (Next
 Top Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，需要停顿线程，当耗时很短。  
 
并发标记 —— 从 GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，当可与用户程序并发执行  
 
最终标记 —— 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，停顿线程，但是可并行执行。  
 
筛选回收 —— 首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。停顿线程。

### 空间分配担保
在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件，那么 Minor GC 可以确保是安全的。  

如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许失败，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行以此 Minor GC，尽管这次 Minor GC 是由风险的；  

如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行以此 Full GC。  

JDK 6 Update 24 之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略。  

规则变为：只要老年代的**连续空间大于新生代对象总大小**或者**历次晋升的平均大小**就会进行 Minor GC，否则进行 Full GC。  

### Out Of Memory
程序计数器：是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域。  

Java 虚拟机栈，也会产生 OOM 异常，规定了两种异常：
- 若线程请求的栈深度 > 虚拟机所允许的深度，则抛出 Stack OverFlowError 异常
- 若虚拟机可以动态扩展，若扩展时无法申请到足够的内存空间，则抛出 OOM 异常
  
本地方法栈：为虚拟机使用 native 方法服务，本地方法栈也会抛出 Stack OverFlowError 和 OOM  

Java 堆：可以处于物理上不连续的内存空间，只要逻辑上是连续的即可。可固定，可扩展。若堆中没有内存完成实例分配，并且堆也无法再扩展，则会抛出 OOM。  

直接内存：不是运行时数据区的一部分，当跟本机的物理内存挂钩。  

### JVM 参数
-Xms：堆最小容量  
-Xmx：堆最大容量  
-Xmn：年轻代大小  
-Xss：每个线程的栈大小  
-XX：SurvivorRatio：表示 Eden 和 1个Survivor的大小之比  

### Java内存模型和线程
下面 8 个操作都是原子的，不可再分的：
1. lock：作用于主内存的变量，它把一个变量标识为一个线程独占的状态。  
2. unlock：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。  
3. read：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存，以便随后的 load 操作使用。  
4. load：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
5. use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时，将会执行这个操作。  
6. assign：作用于工作内存的变量，它把一个从执行引擎接受到的值付给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
7. store：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后 write 使用。
8. write：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。


### 线程的状态
在任意一个时间点，一个线程只能有且只有其中的一种状态。  
- **创建**：创建后尚未启动的线程处于这种状态。  
- **运行**：包括了 OS 中的 Running 和 Ready 状态，也就是处于此状态的线程可能正在运行，也可能正在等待 CPU 为它分配执行时间。  
- **无限期等待**：处于这种状态的线程不会被分配 CPU 执行时间，要等待其他线程显式唤醒。如，object.wait()、thread.join()、LockSupport.park()。
- **有限期的等待**：处于这种状态的线程也不会被分配 CPU 执行时间，不过无需等待被其他线程唤醒，而是在一定时间后，它们会由 OS 自动唤醒。例如，设置了超时的 wait、join、parkNanos()、parkUnit()。
- **阻塞**：线程被阻塞了 与 “等待状态” 的区别是：阻塞状态在等待获取一个排它锁，如I/O 事件，这个事件将在另外一个线程放弃这个锁的时候发生。等待状态在等待一段时间 或者 唤醒动作。
- 结束：已终止线程的线程状态，线程已经结束运行。

### Synchronized VS Lock
1. Lock 是接口，synchronized 是关键字。
2. synchronized 在发生异常时，会自动释放线程占有的锁，不会发生死锁。Lock 在发生异常时，若没有主动通过 unlock() 释放锁，则很有可能造成死锁。所以用 lock 时，要在 finally 中释放锁。
3. Lock 可以在等待锁的线程响应中断，而 synchronized 不行，使用 synchronized 时，等待的线程将会一直等下去，不能响应中断。
4. 通过 Lock 可以知道是否成功获得锁，synchronized 不可以。
5. Lock 可以提高多个线程进行读写操作的效率。