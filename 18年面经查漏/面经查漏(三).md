### MyBatis @Transactional 自调用使得事务失效原因
> 详见  
[博客地址1](https://blog.csdn.net/ligeforrent/article/details/76033083)  
[博客地址2](https://blog.csdn.net/rap_libai/article/details/79232864)  
[博客地址3](https://blog.csdn.net/gudejundd/article/details/54380141) 


### Spring自动加载，使用实现类无法加载，使用接口却可以原因
> 详见  
[博客地址](https://blog.csdn.net/ligeforrent/article/details/76033083) 

### annotation-config,annotation-scan,annotation-driven区别
> 详见  
[博客地址](https://blog.csdn.net/bks429/article/details/78528252)  

### slf4j 和 log4j 的区别，以及为什么应该使用 slf4j
> 详见  
[博客地址](https://blog.csdn.net/minicto/article/details/52672472)

### slf4j 使用
> 详见  
[博客地址](http://www.cnblogs.com/qlqwjy/p/9275415.html)

### 如何使用Spring Test+JUnit
> 详见  
[博客地址1](https://blog.csdn.net/shan9liang/article/details/40452469)  
[博客地址2](https://blog.csdn.net/qq_35209780/article/details/64444186)  
[博客地址3](https://blog.csdn.net/yaerfeng/article/details/25368447)

### java.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized.
> 详见  
[博客地址](https://blog.csdn.net/github_35186068/article/details/80919528)  

### jdbcType的类型必须是大写的，否则会illegalStatementException  

### 如何对 % 运算进行优化
可以使用 & 位运算来代替 % 运算，但是需要被除数为 2的整数次幂，例如：  
a % b，其中（b = 2 ^ n)  
则a % b == a & (b - 1)  

HashMap 的底层实现，就是通过这种方法来进行求余计算，进而找到所要找的 entry
> 详见   
[地址1](http://ifeve.com/mod-and-or/)  
[地址2](https://blog.csdn.net/FIRE_TRAY/article/details/48397917)  

### Java深入理解泛型类、泛型接口、泛型方法
> 详见  
[博客地址](https://blog.csdn.net/claram/article/details/51899898)  

### Java理解泛型通配符 ? extends Class 和 ? super Class 和 PECS原则
> 详见  
[博客地址](https://blog.csdn.net/jeffleo/article/details/52250948)  

### 理解 MySQL 的四种隔离级别
> 详见  
[简书地址](https://www.jianshu.com/p/8d735db9c2c0/)   

在 MySQL 中 Repeatable Read 隔离级别中，innodb 已经避免了幻读的可能性了，采用了 S锁+间隙锁  

幻读是指：在同一事务中，不同的时间，读到的记录数量不一致  

> 详见  
[Mysql如何避免幻读](https://blog.csdn.net/ashic/article/details/53735537)


### MySQL 性能优化
> 详见  
[博客地址](https://blog.csdn.net/jeffleo/article/details/61423591)  


### 字符集 和 字符编码 的区别
> 详见  
[博客地址](http://cenalulu.github.io/linux/character-encoding/)  

### 正向代理、反向代理 和 透明代理的区别
> 详见  
[博客地址](http://blog.51cto.com/z00w00/1031287)  

### Java 泛型的详解
> 详见  
[博客地址](https://www.cnblogs.com/coprince/p/8603492.html)  

静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。  

即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。  

> 总结  
无论何时，如果你能做到，你就该尽量使用泛型方法。  
也就是说，如果使用泛型方法将整个类泛型化,那么就应该使用泛型方法。  
另外对于一个static的方法而已，无法访问泛型类型的参数。  
所以如果static方法要使用泛型能力，就必须使其成为泛型方法。


### Java的 String.split()
> 详见  
[博客地址](https://www.cnblogs.com/mingforyou/archive/2013/09/03/3299569.html)  

当想要使用 split(".") 时是不可以的，因为 . 是转义字符，需要用 \\\ 来进行转义  

需写做 split("\\\\.") 才可以  

同理，想用 | 做分割符 也需要进行转义  
### JVM 中的逃逸分析
> 详见  
[博客地址](http://www.importnew.com/23150.html)  
[博客地址1](https://my.oschina.net/hosee/blog/638573)
  
  
> 逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为  方法逃逸。  

例如：  
```
public static StringBuffer craeteStringBuffer(String s1, String s2) {
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        sb.append(s2);
        return sb;
    }
```
StringBuffer sb 是一个方法内部变量，上述代码中直接将 sb 返回，这样这个 StringBuffer 有可能被其他方法所改变，这样他的作用域就不只是在方法内部了，虽然他是一个局部变量，称其逃逸到了方法的外部  

甚至还有可能被外部线程访问到，譬如 赋值给类变量 或 可以在其他线程中访问的实例变量，称为 线程逃逸  

