### 二叉树
1. 所有非叶子结点至多拥有两个儿子。  
2. 所有结点存储一个关键字。
3. 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树。

#### 二叉树的搜索
从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；  

否则，如果查询关键字比结点关键字小，就进入左儿子结点；  

如果比结点关键字大，就进入右儿子结点；  

如果左儿子或右儿子的指针为空，则报告找不到相应关键字。  
![二叉树](https://github.com/z2oo/notes/raw/master/picSrc/%E4%BA%8C%E5%8F%89%E6%A0%91.JPG)  
如果二叉树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么二叉树的搜索性能逼近二分查找。  

但它比连续内容空间的二分查找的优点是：改变二叉树的结构（插入与删除结点）不需要移动大段的内存数据，甚至是常数开销。  

![二叉树插入结点](https://github.com/z2oo/notes/raw/master/picSrc/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5.JPG)  

但二叉树在经过多次插入与删除后，有可能导致不同的结构：  
![31](https://github.com/z2oo/notes/raw/master/picSrc/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%80%E5%8C%96.JPG)  

右边也是一个二叉树，但它的搜索性能已经是线性的了。  

同样的关键字集合有可能导致不同的树结构索引；所以，使用二叉树还要考虑尽可能让二叉树保持左图的结构，和避免右图的结构，即所谓的“平衡”问题。  

实际使用的二叉树都是在原二叉树的基础上加上平衡算法，即“平衡二叉树”  

如何保持二叉树结点分布均匀的平衡算法是平衡二叉树的关键。  

### B 树（B-树）
B 树是一种适用于外查找的树，它是一种平衡的多叉树，称为 B 树（或 B-树）。  

![623088-20160722072019154-520046449](https://github.com/z2oo/notes/raw/master/picSrc/B-%E6%A0%911.png)    
  
![4](https://github.com/z2oo/notes/raw/master/picSrc/B%E4%B9%98%E6%A0%91.JPG)  

B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子结点为空，或已经是叶子结点。  

#### B-树的特性：
1. 关键字集合分布在整棵树中。  
2. 任何一个关键字出现且只出现在一个结点中。
3. 搜索有可能在非叶子结点结束。
4. 其搜索性能等价于在关键字全集内做一次二分查找。
5. 自动层次控制。  
 
由于限制了除根结点以外的非叶子结点，至少含有 M/2 个儿子，最多含有 M 个儿子，确保了结点的至少利用率，其最低搜索性能为   
![0](https://github.com/z2oo/notes/raw/master/picSrc/B-%E6%A0%91%E6%80%A7%E8%83%BD.JPG)  

其中，M为设定的非叶子结点最多子树个数，N为关键字总数；  

所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题。  

由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占 M/2 的结点；删除结点时，需将两个不足 M/2 的兄弟结点合并。  


### B+树
B+树是B-树的变体，也是一种多路搜索树。  

其定义基本与 B-树相同，除了:
1. 非叶子结点的子树指针与关键字个数相同。  
2. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）。
3. 为所有叶子结点增加一个链指针。
4. 所有关键字都在叶子结点出现
![5](https://github.com/z2oo/notes/raw/master/picSrc/B%2B%E6%A0%91.JPG)  

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。  

#### B+数的特性
1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字是有序的。  
2. 不可能在非叶子结点命中。
3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。
4. 更适合文件索引系统。


### B*树
是 B+树的变体，在 B+树的非根和非叶子结点在增加指向兄弟的指针。  
![6](https://github.com/z2oo/notes/raw/master/picSrc/B%E4%B9%98%E6%A0%91.JPG)

B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）。  

#### B+树和 B*树的分裂
 B+树的分裂：   
当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。 

B*树的分裂：  
当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。  

所以，B*树分配新结点的概率比B+树要低，空间使用率更高。

### 红黑树
红黑树（Red-Black Tree）是二叉搜索树（Binary Search Tree）的一种改进。  

我们知道二叉搜索树在最坏的情况下可能会变成一个链表（当所有节点按从小到大的顺序依次插入后）。  

而红黑树在每一次插入或删除节点之后都会花O（log N）的时间来对树的结构作修改，以保持树的平衡。  

也就是说，红黑树的查找方法与二叉搜索树完全一样；插入和删除节点的的方法前半部分节与二叉搜索树完全一样，而后半部分添加了一些修改树的结构的操作。  

红黑树的每个节点上的属性除了有一个key、3个指针：parent、lchild、rchild以外，还多了一个属性：color。它只能是两种颜色：红或黑。  

红黑树除了具有二叉搜索树的所有性质之外，还具有以下4点性质： 
1. 根结点是黑色的。
2. 空结点是黑色的（红黑树中，根结点的 parent 以及所有叶节点 lchild、rchild 都不指向 null，而是指向一个定义好的空结点）。
3. 红色结点的 parent、lchild、rchild结点都是黑色的。  
4. 在任何一棵子树中，每一条从根结点向下走到空结点的路径上包含的黑色结点数量都相同。  

### 树小结
- B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点。  
- B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点。
    - 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中。
- B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。
- B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3。

