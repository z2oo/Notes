# 计算机系统结构的基本概念
## 计算机系统的层次结构
计算机系统是由硬件和软件组成的  

　　从使用语言的角度出发，可把计算机系统按功能划分为多级层次结构，每一层以一种不同的语言为特征  

- 第6级：应用语言机器(虚拟机)　　　高
- 第5级：高级语言机器(虚拟机)　　　｜
- 第4级：汇编语言机器(虚拟机)　　　｜
- 第3级：操作系统机器(虚拟机)　　　｜
- 第2级：传统机器语言机器(物理机)　｜
- 第1级：微程序机器(物理机)　　　　低
 
第1级：用微指令编写的微程序直接由**固件/硬件**来**解释**实现  
1级上可以有多个能够在它上面运行的**解释程序**，每个解释程序定义了一种指令`系统(仿真)，即在一台电脑上可实现多种指令系统  

第2级：即传统的**机器指令系统**，程序员用该系统编写的程序由第1级上的微程序进行**解释执行**  
        
第3级———传统机器级指令  
　　|———操作系统级指令----用于实现对操作系统功能的调用(打开/关闭文件、读/写文件等)  
这一级编写的程序是由第3级(自身)和第2级来共同执行的，其中，只有**操作系统级指令**是由**操作系统**进行**解释执行**的  

第4级：用汇编语言写的程序首先**翻译**成**第3级**和**第2级**语言，然后在用**相应的机器**执行。完成这个翻译的程序称为**汇编程序**  

第5级：用高级语言编写的程序一般由**编译器**翻译到**第4级**或**第3级**机器上的语言，个别的高级语言也用解释的方法实现(BASIC)  

第6级：这一级是为使计算机满足**某种用途**而设计的，因此这一级的语言就是各种面向具体应用问题的**应用语言**。一般由应用**程序包**翻译成第5级上的语言  

各机器级的实现主要靠**翻译**或**解释**，或两者结合  

　　翻译(translation)：即编译，先用转换程序把**高一级**机器上的程序**转换**为低一级机器上等效的程序，然后再在该**低一级**机器上运行，实现程序的功能  

　　解释(interpretation)：对于高一级机器上的程序的**每一条**语句或指令，都转去执行低一级机器上的等效代码。执行完毕后，再去高一级机器取下一条语句或指令，再进行**解释执行**，如此重复，直至解释执行整个程序  
  
一般，解释执行比编译后在执行所**花的时间多**，但占用的**存储空间较少**  

下面三级一般是用**解释实现**的，而上面三级一般用**翻译**的方法实现的  

最下面2级机器使用**硬件/固件**实现的，称为**物理机(Physical Machine)**  
上面4级一般由**软件**实现的，用**软件**实现的机器称为**虚拟机(Virtual Machine)**  
不过，虚拟机不一定完全由软件实现的，有些操作可以由**硬/固**实现  
  
> 固件(firmware)：是指具有软件功能的硬件。例如，把软件固化在只读存储器就是一种固件，通过修改固件的软件代码就可以改变其功能  
固件与硬连逻辑相比，固件的特点是灵活性大，但速度较慢  

## 计算机系统结构的定义
计算机系统结构(Computer Architecture)的经典定义：指传统机器程序员所看到的计算机属性，即概念性结构与功能特性。按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性  
例：  
**传统机器程序员**看到的主要属性是：该机器**指令系统**的功能特性，而**高级语言虚拟机程序员**所看到的主要属性则是：该机器所配置的**高级语言**所具有的功能特性  
  
不同的计算机系统，从**传统机器级**或**汇编语言程序员**的角度来看，具有不同的属性  
但，从高级语言程序员的角度来看，它们几乎没有什么差别，具有相同的属性  
也就是说，**这些传统机器级所存在的差别对于高级程序员来讲是“看不见的”**  

在计算机技术中，把这些**本来存在**的事物或属性，但从**某种角度看**又好像不存在的概念称为**透明性(transparency)**  

通常，在一个计算机系统中，低层机器的属性对高层机器的程序员来说，往往是透明的  
  
计算机系统结构的**实质**是：**确定计算机系统中软硬件的交界面，界面之上是软件实现的功能，界面之下是固和硬件实现的功能**  

## 计算机组成和计算机实现
**计算机组成(Computer Organization)**  
　　指的是计算机系统结构的**逻辑实现**，包括物理机器级中的**数据流**和**控制流**的组成以及**逻辑设计**等。它着眼与物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系  
 
**计算机实现(Computer Implementation)**  
　　指的是**计算机组成**的**物理实现**，包括处理机、主存等部件的物理结构，器件的集成度和速度，模块、插件、底板的划分与连接，信号传输，电源、冷却及整机装配技术等。它着眼于器件技术和微组装技术，其中器件技术在实现技术中起主导作用  
  
例如  
1. 确定指令系统中**是否有乘法指令**属于**计算机系统结构**的内容，但乘法指令**是用专门的乘法器实现，还是用加法器经多步加法操作来实现**，属于**计算机组成**。而乘法器、加法器的**物理实现**，如器件的选定及所用的微组装技术等，属于**计算机实现**  
2. 主存容量与编址方式(按位、按字节或按字访问等)的确定属于**计算机系统结构**。为了达到给定的性能价格比，主存速度应多快、**逻辑结构**是否采用多体交叉等属于**计算机组成**。而主存系统的**物理实现**，如器件的选定、逻辑电路的设计、微组装技术的使用等均属于**计算机实现**  

## 计算机系统结构的分类
常见的计算机系统结构分类法有三种，**Flynn分类法**、**冯氏分类法**和Handler分类法  
### 1.Flynn分类法
Flynn分类法是按照**指令流**和**数据流**的**多倍性**进行分类的  
　　**指令流(Instruction Stream)**：计算机执行的指令序列  
　　**数据流(Data Stream)**：由指令流调用的数据序列  
　　**多倍性(Multiplicity)**：在系统最受限的部件上，同时处于同一执行阶段的指令或数据的最大数目  
  
Flynn分类法把计算机系统的结构分为以下4类：
1. **单指令流单数据流(SISD)**
2. **单指令流多数据流(SIMD)**
3. **多指令流单数据流(MISD)**
4. **多指令流多数据流(MIMD) **　　
 
SISD是传统的**顺序处理**计算机。SIMD以**阵列处理机**为代表。在SIMD计算机中，在同一控制部件的控制下，**多个处理部件**同时执行**同一条指令**所规定的操作，分别对各自的数据进行处理。这些数据来自不同的地方，分别构成各自的数据流。MISD只是一种人为的划分，没有实际的机器。**多处理机**属于MIMD机构  

### 2.冯氏分类法
冯氏分类法是用系统的**最大并行度**对计算机进行分类的。  
最大并行度Pm定义为：计算机系统在单位时间内能够处理的最大二进制位数  
根据分类，有以下4类：
1. **字串位串**：n=1，m=1.纯串行计算机
2. **字串位并**：n>1，m=1，传统的单处理机，同时处理单个字的多个位，如16位、32位等
3. **字并位串**：n=1，m>1。同时处理多个字的同一位(位片)
4. **字并位并**：n>1，m>1.同时处理多个字的多个位    

最大并行度**Pm=m\*n**  
　　与最大并行度密切相关的一个指标识平均并行度。假设每个时钟周期内能同时处理的二进制位数为Pi，则T个时钟周期内的平均并行度为pa=ΣPi　/　T 。平均并行度不同于最大并行度，它取决于系统的运行程度，与应用程序有关。  
系统在T个时钟周期内的平均利用率定义为μ=Pa　/　Pm   
### 3.Handler分类法
略
  
# 计算机系统的设计
## 计算机系统设计的定量原理
### 1.以经常性事件为重点  
**加快经常性事件的处理速度**能显著提高整个计算机系统的性能  
例如  
　　在CPU中，两个数进行相加运算时，相加的结果有可能会出现溢出现象，但一般情况是不会发生溢出的，也就是说不经常发生溢出时经常性时间。因此应该按照不发生溢出的情况来进行性能优化设计。即使会使溢出情况下的处理速度变慢也没关系
### 2.Amdahl定律
Amdahl定律告诉我们：  
当对一个系统中的某个部件进行改进后，所能获得的整个系统性能的提高，受限于该部件的执行时间占总执行时间的百分比。  
它可以用来具体地计算：当对计算机系统中的某个部分进行改进后，所能获得的**加速度比**的大小  

加速比说明了改进后的计算机比改进前快了多少倍  
**加速比=系统性能(改进后) / 系统性能(改进前) =总执行时间(改进前)　/　总执行时间(改进后)**   

这个加速比的大小与两个因素有关  

1. 一个是在改进前的系统中，可改进部分的执行时间在总的执行时间中所占的比例，简称 **可改进比例**，记为 **Fe**。Fe总是小于1的  

2. 另一个是可改进部件改进以后性能提高的倍数。它**是改进前所需要的执行时间与改进后执行时间的比**，简称**部件加速比**，记为**Se**。Se总是大于1  

例如：  
一个需要运行60s的程序中有20s的运算可以加速，那么其Fe就是20/60。若该系统改进后，可改进部分的执行时间减少为5s，则其Se为20/5  

部件改进后，程序中可改进部分的执行时间被缩短为原来的1/Se，但不可改进部分的执行时间没有变化。所以改进后程序的总执行时间为：  
　　**Tn=T0(1-Fe+Fe/Se)**  

其中，T0为改进前整个程序的执行时间，1-Fe为不可改进比例  
改进后，整个系统的加速比为  
　　**Sn=T0　/　Tn = 1　/　((1-Fe)+Fe/Se)**  

例，  
将计算机系统中某一功能的处理速度加快15倍，但该功能的处理时间仅占整个系统运行时间的40%，则采用此改进方法后，能使整个系统的性能提高多少?  
解：  
由题可知，Fe=40%=0.4,Se=15  
根据Amdahl定律可知  
Sn=1　/　((1-Fe)+Fe/Se)=1　/　((1-0.4)+0.4/15)=1.6  
所以，采用此改进方法后，能使整个系统的性能提高到原来的1.6倍  

### 3.CPU性能公式
执行一个程序所需的CPU时间可以这样计算  
　　**CPU时间=执行程序所需的时钟周期数 × 时钟周期时间**  
其中，时钟周期时间是时钟频率的倒数  

引入新的参数**CPI(Cycles Per Instruction)**，即**每条指令的平均时钟周期数**，有时简称为指令的平均时钟周期数  
　　**CPI=执行程序所需的时钟周期数　/　所执行的指令条数**  

则有以下的CPU性能公式  
**CPU时间=IC　×　CPI　×　时钟周期时间**  
其中IC为所执行的指令条数  
  
根据这个公式可知，CPU的性能取决于以下三个参数  
1. 时钟周期时间：取决于硬件实现技术和计算机组成
2. CPI：取决于计算机组成和指令系统的结构
3. IC：取决于指令系统的机构和编译技术

CPU设计中还经常用到下面计算CPU时钟周期总数的方法  
　　**CPU时钟周期数=Σ(CPIi　×　ICi)**  
其中，ICi为程序执行的过程中第i中指令出现的次数，CPIi为执行第i种指令所需的平均时钟周期数，n为指令的种数  

这时的CPU性能公式为  
　　**CPU时间=CPU时钟周期数 ×　时钟周期时间  
　　　　=Σ(CPIi　×　ICi)　×　时钟周期时间**  

CPI可以表示为  
**CPI=时钟周期数 / IC=Σ(CPIi×ICi)/IC =Σ(CPIi　×　ICi/IC)**  
其中(ICi/IC)反映了第i种指令在程序执行过程中所占的比例   
  
例  
假设FP指令的比例为25%，其中，FPSQR占全部指令的比例为2%，FP操作的CPI为4，FPSQR操作的CPI为20，其他指令的平均CPI为1.33。现有两种改进方案，第一种是把FPSQR操作的CPI减至2，第二种是把所有的FP操作的CPI减至2，试比较两种方案对系统性能的提高程度  

解  
没有改进之前，每条指令的平均时钟周期(CPI)为  
　　CPI=Σ(CPIi ×　ICi/IC)=(4\*25%)+(1.33\*75%)≈2  
(1)采用第一种方案：FPSQR操作的CPI由20减至2，则整个系统的指令平均时钟周期为  
　　CPI1=CPI-(CPI-CPI')=2-(20-2)*2%=1.64  

(2)采用第二种方案：所有FP操作的CPI由CPI=4减至2，则整个系统的指令平均时钟周期数为  
　　CPI2=CPI-(CPI-CPI')=2-(4-2)*25%=1.5  

从降低整个系统的指令平均时钟周期数的程度来看，第二种方案优于第一种方案  

### 4.程序的局部性原理
**程序的局部性原理(Principle of Locality)**是人们经常加以利用的程序属性。  

　　它是指：程序执行时所访问的存储器地址不是随机分布的，而是相对地簇聚。现在常用的一个经验规则是：程序执行时间的90%都是在执行程序中10%的代码。数据访问也具有局部性，不过其局部性弱于代码访问的局部性  

局部性包括时间局部性和空间局部性。  
- **时间局部性**：程序即将用到的信息很有可能就是目前正在使用的信息  

- **空间局部性**：程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或邻近  

利用程序的局部性原理，可以根据程序最近访问情况来比较准确地预测将要访问的指令和数据。凡是涉及数据重要的地方都可能用到它  

## 计算机系统涉及的主要方法
可分为**“由上往下”**、**“由下往上”**和**“从中间开始”**三种不同的设计方法  

# 计算机系统的性能评测
## 1.执行时间和吞吐率
对于桌面台式机来说，用户说计算机很快，是指它执行单个程序所花的时间很少  
而对于数据处理中心的管理员来说，计算机很快则是指它在单位时间里能够完成的任务很多  

前者关心的是当个程序的**执行时间(Execution Time)**，而后者关心的则是**吞吐率(throughput)**  
## 2.基准测试程序  
## 3.性能比较
  

# 计算机系统结构的发展
## 冯诺依曼结构及其改进  
最早的存储程序式计算机是美籍数学家冯诺依曼等人于1946年总结并提出来的，它由运算器、控制器、存储器、输入设备和输出设备5部分构成  

　虽然与冯诺依曼结构相比，现代的计算机系统结构已经发生了很大的变化，但就其结构原理来说，占主流地位的仍是改进了的冯诺依曼结构计算机  

冯诺依曼结构的主要特点如下：  
1. 计算机以运算器为中心。输入输出设备与存储器之间的数据传送都经过运算器；存储器、输入输出设备的操作，并且他们之间的联系都由控制器集中控制  

2. 在存储器中，指令和数据同等对待。指令和数据一样可以进行运算，即由指令组成的程序是可以修改的  
3. 存储器是按地址访问、按顺序线性编址的一维结构，每个单元的位数是固定的  
4. 指令的执行是顺序的，即一般是按照指令在存储器中存放的顺序执行的。程序的分支由转移指令实现。由程序计数器(PC)指明当前正在执行的指令在存储器中的地址  
5. 指令由**操作码**和**地址码**组成。操作码指明**本指令的操作类型**，地址码指明**操作数地址**和**存放运算结构的地址**。操作数的类型是由操作码**决定**的，操作数本身不能判定是何种数据类型  
6. 指令和数据均以二进制编码表示，采用二进制运算  

<br/>
　　后来的计算机针对冯诺依曼结构的不足之处进行了不断的改进，主要包括以下几方面：  

(1)对输入输出方式的改进  
　　冯诺依曼结构以运算器为中心，所有部件的操作都由控制器集中控制。这使得输入输出操作与运算操作只能串行进行，运算器成为了整个系统的瓶颈。人们先后提出了多种输入输出方式，如下图   
```
输入输出方式
    |——程序控制
    |        |——程序等待
    |        |——程序中断
    |——DMA
    |     |——成组传递
    |     |——周期挪用
    |——I/O处理机
    |       |——通道
    |       |——外围处理机
        
```
(2)采用并行处理技术  
(3)存储器组织结构的发展  
(4)指令系统的发展  

## 软件对系统结构的影响
实现可移植性的常用方法有三种：统一高级语言、采用系列及、模拟和仿真  
### 1.统一高级语言
由于高级语言是面向问题和算法的，与计算机的具体结构关系不大，如果个计算机能采用同一种高级语言，那么用这种语言编写的应用软件和系统软件(或部分系统软件)的可移植问题就解决了
### 2.采用系列机
系列机是指由同一厂家生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的计算机  
　　由于从机器语言程序员的角度来看，同一系列的各档计算机的属性都是相同的，因此按这个属性编制或编译生成的二进制代码都能不加修改地通用于各档计算机  
　　系列机的软件兼容有4种：**向上兼容**、**向下兼容**、**向前兼容**和**向后兼容**  
### 3.模拟和仿真
**模拟(simulation)**是指用软件的方法在一台现有的计算机(称为宿主机host)上实现另一台计算机(称为虚拟机)的指令系统。  
　　模拟通常用**解释**的方法来实现，即虚拟机的每一条指令都用宿主机的一旦程序进行解释执行。为了能使虚拟机的应用程序能在宿主机上运行，除了模拟虚拟机的指令系统外，还要模拟其存储系统、I/O系统、操作系统等。由于模拟是采用纯软件解释执行的方法，因此运行速度较慢，性能较差  
　　仿真是指用一台现有计算机(称为宿主机)上的微程序去解释实现另一台计算机(称为目标机)的指令系统。这个微程序是专门为实现目标机指令系统而设计的，称为仿真微程序。同样，处理仿真目标机的指令系统以外，还需要仿真其存储系统、I/O系统、控制台操作等  
  
仿真和模拟的主要区别在于**解释执行所用的语言**。  

仿真使用微程序解释执行的，其解释程序存放在控制存储器中；而模拟是用机器语言程序程序解释执行的(虽然模拟程序可以用高级语言编写，但最后执行时是机器代码)，模拟程序存放在主存中。  

因此，仿真的运行速度比模拟方法的**快**，但仿真只能在系统结构差距不大的计算机之间使用，当两种计算机结构差别比较大时，就很难仿真。  
为了取长补短，可以以将这两种方法混合使用  

# 计算机系统结构中并行性的发展
## 并行性的概念
**并行性(parallelism)**是指计算机系统在同一时刻或同一时间间隔内进行多种运算或操作。只要在时间上相互重叠，就存在并行性。它包括同时性和并发性两种含义  
　　**同时性(simultaneity)——两个或两个以上的时间在同一时刻发生**  
　　**并发性(concurrency)——两个或两个以上的时间在同一时间间隔内发生**  

计算机系统中的并行性有不同的等级。  
从处理数据的角度来看，并行性等级从低到高可分为以下几种：
1. 字串位串：每次只对一个字的一位进行处理。这是最基本的串行处理方式，不存在并行性  

2. 字串位并：同时对一个字的全部位进行处理，不同字之间是串行的。具备初步的并行性。这种并行性称为位级并行  
3. 字并位串：同时对许多字的同一位(称为位片)进行处理。这种方式具有较高的并行性  
4. 全并行：同时对许多字的全部位或部分位进行处理  

从执行程序的角度来看，并行性等级又可分为：
1. 指令内部并行：指令内部并行是指单条指令中各微操作之间的并行  

2. 指令级并行：是指并行或并发地执行两条或两条以上的指令
    - 流水线技术使得多条指令能重叠地执行，提高了CPU执行程序的吞吐率。
    - 超标量的方法则更进一步，使得计算机能每个时钟周期启动多条指令，并能由多条流水线在单周期内产生多个运算记过。超标量主要是用来开发指令级并行的  
    
3. 线程级并行：指并行执行两个或两个以上的线程
    - 线程是进程内的一个相对独立、可独立调度和指派的执行单元，它比进程要“轻巧”很多。线程中包含有调度需要的信息，但它可以基本上不拥有系统资源，只拥有在运行过程中必不可少的一点资源，如程序计数器、一组寄存器、堆栈等
    - 所以线程切换时，只需保存和设置少量寄存器的内容，开销很小
    - 多线程既能提高程序的并发和并行度，又能减少操作系统的开销。它与多核技术相结合，能达到很好地开发并行性的效果  
4. 任务级或过程级并行：指并行执行两个或两个以上的过程或任务(程序段)，以子程序或进程为调度单元
5. 作业或程序及并行：并行执行两个或两个以上的作业或程序  
## 提高并行性的技术途径
1. 时间重叠(Time Interleaving)：在并行性概念中引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度。流水线技术是时间重叠的典型实例  

2. 资源重复(Resource Replication)：在并行性概念中引入空间因素，以数量取胜。通过重复设置硬件资源，大幅度地提高计算机系统的性能。在现在的计算机系统中，经常是同时运用时间重叠和资源重复  
3. 资源共享(Resource Sharing)：这是一种软件方法，它使多个任务按一定的时间顺序轮流使用同一套硬件设备。多道程序、分时系统就是遵循这一途径而产生的。资源共享既降低了成本，又提高了计算机设备的利用率  

## 单机系统中并行性的发展
在发展高性能单处理机的过程中，起主导作用的是时间重叠原理。  

实现时间重叠的基础是“部件功能专用化”，即把一件工作按功能分割为若干相互联系的部分，把每一部分指定给专门的部件完成，然后按时间重叠原理把各部分的执行过程在时间上重叠起来，使所有部件依次分工完成一组同样的工作。  

例如：把一条指令的解释过程分为4个子过程：取指令、指令译码、指令执行、写回结果，为每个子过程分配一个专用部件，并将它们的工作按某种时间关系重叠起来，就构成了指令流水线  

在单处理机系统中，资源重复原理的运用也已经十分普遍。例如，多体存储器和多操作部件都是成功应用的结构形式  

在多操作部件处理机中，通用部件被分解成若干个专用部件，如加法部件、乘法部件、除法部件、逻辑运算部件等，而且同一种部件也可以重复设置多个。只要指令所需的操作部件空闲，就可以开始执行这条指令(如果操作数已准备好的话)，这就实现了指令级并行  

在单处理机中，资源共享的概念实质上是用单处理机模拟多处理机的功能，形成所谓虚拟机的概念。  
例如，  
分时系统，在多终端的情况下，每个终端上的用户都感觉好像自己拥有一台处理机一样  

