## 类加载器
### 类加载的一些重要方法
#### loadClass方法
ClassLoader.loadClass()是ClassLoader的入口点，该方法的定义如下：  
` Class loadClass ( String name, boolean resolve) `  
name 是指 JVM 需要的类的名称，resolve 参数告诉方法是否需要解析类。  
> 注意：并不总是需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，那么久不需要解析

#### defineClass方法
defineClass 方法接受由原始字节组成的数组，并把它转换成 Class 对象。
#### findSystemClass方法
findSystemClass 方法从本地文件系统装入文件。它在本地文件系统中寻找类文件，如果存在，就使用 defineClas 将原始字节转换成 Class 对象，以将该文件转换成类。  

当运行 Java 应用程序时，这是 JVM 正常装入类的默认机制。
#### resolveClass方法
是否调用此方法，取决于 loadClass 的 resolve 参数的值。
#### findLoadedClass方法
findLoadedClass 充当一个缓存：当请求 loadClass 装入类时，它调用方法来查看 ClassLoader 是否已经装入这个类，这样可以避免重新装入已存在类所造成的麻烦。
#### findClass方法
loadClass 默认实现调用这个新方法。目的是从本地文件系统使用实现的类装载器装载一个类
#### getSystemClassLoader方法
这个新方法允许 ClassLoader 获取它的父类 ClassLoader。
#### forName方法
类似 loadClass 方法，用来加载类。  

loadClass 加载类实际上就是加载的时候并不对该类进行解析，因此不会初始化该类  

而使用 forName 加载的时候就会将 Class进行解析和初始化  

> 类加载分 3 个阶段：加载、链接、初始化；其中链接又分 3 个阶段：验证、准备、解析。  

> 加载：即将需要用到的 class 文件加载进 内存，将静态数据结构转化成方法区中运行时数据结构，然后生成一个代表该类的 Class 对象存放在堆中（1.7），作为数据访问的入口。  

> 验证：确保加载的类符合 JVM 规范与安全。  

> 准备：为静态变量在方法区中分配空间，设置变量的初始值，这里的初始值不是用户自定义的初始值，而是 0 、false、null、""。

> 解析：主要将常量池中的符号引用转换成直接引用。

> 初始化：初始化阶段是执行类构造器<clinit>()方法。在类构造器中，它将由编译器自动收集类中的所有类变量的赋值动作(准备阶段的a正是被赋值a)和静态变量与静态语句块static{}合并，等待初始化时机。

## Java 编码
### Java字符表示形式
JVM 的设计者当初决定 JVM 中所有字符的表示形式时，是不允许使用各种编码方式的字符并存的。  

这是因为，如果在内存中的 Java 字符可以以 GB2312、UTF-16、BIG5 等各种编码形式存在，那么对开发者来说，连进行最基本的字符串打印、连接等操作都会寸步难进。  

例如，一个 GB2312 的字符串后面连接一个 UTF-8 的字符串，那么连接后的最终结果应该是什么结果呢？ 所以选择哪一种都没有道理。  

在 Java 中字符只以一种形式存在，那就是 Unicode（不选择任何特定的编码，直接使用它们在字符集中的编号，这是统一的唯一方法）。  

在 Java 中，只要你正确地读入了某个字符，那么它在内存中的表示形式一定是0xXXXX，没有任何其他的值能代表这个字。  

JVM 的这种约定使得一个字符分为两个部分：JVM 内部 和 OS 的文件系统。  

在 JVM 内部，统一使用 Unicode 表示，当这个字符被从 JVM 内部转移到外部（即保存为文件系统中的一个文件的内容时），就进行了编码转换，使用了具体的编码方案。  

因此可以说，所有的编码转换只发生在边界的地方，JVM 和 OS的交界处，也就是各种输入/输出流（或者 Reader、Writer 类）起作用的地方。  
### Java I/O
所有的 I/O 基本上可以分为两大阵营：面向字符的输入/输出流；面向字节的输入/输出流。  

如果面向字节，那么这类工作要保证系统中的文件二进制内容和读入 JVM 内部的二进制内容一致，不能变换任何 0 和 1 的顺序。这种输入/输出方式很适合读入视频文件或者音频文件，或者任何不需要做变换的文件内容。  

面向字符的 I/O 是指希望系统中的文件的字符和读入内存的 “字符” 要一致。
  
面向字符的 I/O 类，也就是 Reader 和 Writer 类，实际上隐式地做了编码转换，在输出时，将内存中的 Unicode 字符使用系统默认的编码方式进行了编码，而在输入时，将文件系统中已经编码过的字符使用默认编码方案进行了还原。  
### 转换
> Reader 和 Writer 只会使用这个默认的编码来做转换，而不能为一个 Reader 或者 Writer 指定转换时使用的编码。这也意味着，如果使用中文版 Windows Xp 系统，其中存放了一个 UTF-8 编码的文件，当采用 Reader 类来读入的时候，它还会使用 GBK 来做转换，转换后的内容当然不对。  

如果用到 GBK 编码以外的文件，就必须采用编码转换：  

一个字符与字节之间的转换。因此，Java 的 I/O 系统中能够指定转换编码的地方，也就在字符与字节转换的地方，那就是 InputStreamReader 和 OutputStreamWriter。  

转换步骤：  
> 如果以文件操作为例，则在内存中的字符数据需要通过OutputStreamWriter变为字节流才能保存在文件之中，读取的时候需要将读入的字节流通过InputStreamReader变为字符流。  

![](https://github.com/z2oo/notes/raw/master/picSrc/InputStreamReader%E5%92%8COutputStreamWriter%E5%8C%BA%E5%88%AB.png)  


